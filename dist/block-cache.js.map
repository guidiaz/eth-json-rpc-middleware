{"version":3,"file":"block-cache.js","sourceRoot":"","sources":["../src/block-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import { PollingBlockTracker } from 'eth-block-tracker';\r\nimport { createAsyncMiddleware, JsonRpcMiddleware } from 'json-rpc-engine';\r\nimport {\r\n  cacheIdentifierForPayload,\r\n  blockTagForPayload,\r\n  cacheTypeForPayload,\r\n  canCache,\r\n  Payload,\r\n  Block,\r\n  BlockCache,\r\n  Cache,\r\n  JsonRpcRequestToCache,\r\n} from './utils/cache';\r\n\r\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\r\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\r\n\r\ninterface BlockCacheMiddlewareOptions {\r\n  blockTracker?: PollingBlockTracker;\r\n}\r\n\r\n//\r\n// Cache Strategies\r\n//\r\n\r\nclass BlockCacheStrategy {\r\n  private cache: Cache;\r\n\r\n  constructor() {\r\n    this.cache = {};\r\n  }\r\n\r\n  getBlockCacheForPayload(\r\n    _payload: Payload,\r\n    blockNumberHex: string,\r\n  ): BlockCache {\r\n    const blockNumber: number = Number.parseInt(blockNumberHex, 16);\r\n    let blockCache: BlockCache = this.cache[blockNumber];\r\n    // create new cache if necesary\r\n    if (!blockCache) {\r\n      const newCache: BlockCache = {};\r\n      this.cache[blockNumber] = newCache;\r\n      blockCache = newCache;\r\n    }\r\n    return blockCache;\r\n  }\r\n\r\n  async get(\r\n    payload: Payload,\r\n    requestedBlockNumber: string,\r\n  ): Promise<Block | undefined> {\r\n    // lookup block cache\r\n    const blockCache: BlockCache = this.getBlockCacheForPayload(\r\n      payload,\r\n      requestedBlockNumber,\r\n    );\r\n    // lookup payload in block cache\r\n    const identifier: string | null = cacheIdentifierForPayload(payload, true);\r\n    return identifier ? blockCache[identifier] : undefined;\r\n  }\r\n\r\n  async set(\r\n    payload: Payload,\r\n    requestedBlockNumber: string,\r\n    result: Block,\r\n  ): Promise<void> {\r\n    // check if we can cached this result\r\n    const canCacheResult: boolean = this.canCacheResult(payload, result);\r\n    if (!canCacheResult) {\r\n      return;\r\n    }\r\n\r\n    // set the value in the cache\r\n    const identifier: string | null = cacheIdentifierForPayload(payload, true);\r\n    if (!identifier) {\r\n      return;\r\n    }\r\n    const blockCache: BlockCache = this.getBlockCacheForPayload(\r\n      payload,\r\n      requestedBlockNumber,\r\n    );\r\n    blockCache[identifier] = result;\r\n  }\r\n\r\n  canCacheRequest(payload: Payload): boolean {\r\n    // check request method\r\n    if (!canCache(payload)) {\r\n      return false;\r\n    }\r\n    // check blockTag\r\n    const blockTag: string | undefined = blockTagForPayload(payload);\r\n\r\n    if (blockTag === 'pending') {\r\n      return false;\r\n    }\r\n    // can be cached\r\n    return true;\r\n  }\r\n\r\n  canCacheResult(payload: Payload, result: Block): boolean {\r\n    // never cache empty values (e.g. undefined)\r\n    if (emptyValues.includes(result as any)) {\r\n      return false;\r\n    }\r\n    // check if transactions have block reference before caching\r\n    if (\r\n      payload.method &&\r\n      ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(\r\n        payload.method,\r\n      )\r\n    ) {\r\n      if (\r\n        !result ||\r\n        !result.blockHash ||\r\n        result.blockHash ===\r\n          '0x0000000000000000000000000000000000000000000000000000000000000000'\r\n      ) {\r\n        return false;\r\n      }\r\n    }\r\n    // otherwise true\r\n    return true;\r\n  }\r\n\r\n  // removes all block caches with block number lower than `oldBlockHex`\r\n  clearBefore(oldBlockHex: string): void {\r\n    const oldBlockNumber: number = Number.parseInt(oldBlockHex, 16);\r\n    // clear old caches\r\n    Object.keys(this.cache)\r\n      .map(Number)\r\n      .filter((num) => num < oldBlockNumber)\r\n      .forEach((num) => delete this.cache[num]);\r\n  }\r\n}\r\n\r\nexport function createBlockCacheMiddleware({\r\n  blockTracker,\r\n}: BlockCacheMiddlewareOptions = {}): JsonRpcMiddleware<string[], Block> {\r\n  // validate options\r\n  if (!blockTracker) {\r\n    throw new Error(\r\n      'createBlockCacheMiddleware - No PollingBlockTracker specified',\r\n    );\r\n  }\r\n\r\n  // create caching strategies\r\n  const blockCache: BlockCacheStrategy = new BlockCacheStrategy();\r\n  const strategies: Record<string, BlockCacheStrategy> = {\r\n    perma: blockCache,\r\n    block: blockCache,\r\n    fork: blockCache,\r\n  };\r\n\r\n  return createAsyncMiddleware(async (req, res, next) => {\r\n    // allow cach to be skipped if so specified\r\n    if ((req as JsonRpcRequestToCache).skipCache) {\r\n      return next();\r\n    }\r\n    // check type and matching strategy\r\n    const type: string = cacheTypeForPayload(req);\r\n    const strategy: BlockCacheStrategy = strategies[type];\r\n    // If there's no strategy in place, pass it down the chain.\r\n    if (!strategy) {\r\n      return next();\r\n    }\r\n    // If the strategy can't cache this request, ignore it.\r\n    if (!strategy.canCacheRequest(req)) {\r\n      return next();\r\n    }\r\n\r\n    // get block reference (number or keyword)\r\n    let blockTag: string | undefined = blockTagForPayload(req);\r\n    if (!blockTag) {\r\n      blockTag = 'latest';\r\n    }\r\n\r\n    // get exact block number\r\n    let requestedBlockNumber: string;\r\n    if (blockTag === 'earliest') {\r\n      // this just exists for symmetry with \"latest\"\r\n      requestedBlockNumber = '0x00';\r\n    } else if (blockTag === 'latest') {\r\n      // fetch latest block number\r\n      const latestBlockNumber = await blockTracker.getLatestBlock();\r\n      // clear all cache before latest block\r\n      blockCache.clearBefore(latestBlockNumber);\r\n      requestedBlockNumber = latestBlockNumber;\r\n    } else {\r\n      // We have a hex number\r\n      requestedBlockNumber = blockTag;\r\n    }\r\n    // end on a hit, continue on a miss\r\n    const cacheResult: Block | undefined = await strategy.get(\r\n      req,\r\n      requestedBlockNumber,\r\n    );\r\n    if (cacheResult === undefined) {\r\n      // cache miss\r\n      // wait for other middleware to handle request\r\n      // eslint-disable-next-line node/callback-return\r\n      await next();\r\n\r\n      // add result to cache\r\n      // it's safe to cast res.result as Block, due to runtime type checks\r\n      // performed when strategy.set is called\r\n      await strategy.set(req, requestedBlockNumber, res.result as Block);\r\n    } else {\r\n      // fill in result from cache\r\n      res.result = cacheResult;\r\n    }\r\n    return undefined;\r\n  });\r\n}\r\n"]}