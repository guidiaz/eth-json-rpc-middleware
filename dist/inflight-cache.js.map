{"version":3,"file":"inflight-cache.js","sourceRoot":"","sources":["../src/inflight-cache.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAC1B,qDAIyB;AACzB,yCAIuB;AAOvB,SAAgB,6BAA6B;IAC3C,MAAM,gBAAgB,GAAoB,EAAE,CAAC;IAE7C,OAAO,uCAAqB,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;QACpD,2CAA2C;QAC3C,IAAK,GAA6B,CAAC,SAAS,EAAE;YAC5C,OAAO,IAAI,EAAE,CAAC;SACf;QACD,4BAA4B;QAC5B,MAAM,OAAO,GAAkB,iCAAyB,CAAC,GAAG,CAAC,CAAC;QAC9D,yBAAyB;QACzB,IAAI,CAAC,OAAO,EAAE;YACZ,OAAO,IAAI,EAAE,CAAC;SACf;QACD,8BAA8B;QAC9B,IAAI,qBAAqB,GAAsB,gBAAgB,CAAC,OAAO,CAAC,CAAC;QACzE,sDAAsD;QACtD,IAAI,qBAAqB,EAAE;YACzB,2DAA2D;YAC3D,uDAAuD;YACvD,MAAM,0BAA0B,CAAC,GAAG,EAAE,qBAAqB,CAAC,CAAC;YAC7D,OAAO,SAAS,CAAC;SAClB;QACD,uDAAuD;QACvD,qBAAqB,GAAG,EAAE,CAAC;QAC3B,gBAAgB,CAAC,OAAO,CAAC,GAAG,qBAAqB,CAAC;QAClD,uCAAuC;QACvC,gDAAgD;QAChD,MAAM,IAAI,EAAE,CAAC;QACb,0BAA0B;QAC1B,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAC;QACjC,+CAA+C;QAC/C,mBAAmB,CAAC,GAAG,EAAE,qBAAqB,CAAC,CAAC;QAChD,WAAW;QACX,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC,CAAC;IAEH,SAAS,0BAA0B,CACjC,GAAkC,EAClC,qBAAwC;QAExC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,eAAe,EAAE,CAAC;QAC/C,qBAAqB,CAAC,IAAI,CAAC,CAAC,UAAyC,EAAE,EAAE;YACvE,wDAAwD;YACxD,GAAG,CAAC,MAAM,GAAG,eAAK,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACtC,GAAG,CAAC,KAAK,GAAG,eAAK,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YACpC,OAAO,EAAE,CAAC;QACZ,CAAC,CAAC,CAAC;QACH,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,SAAS,mBAAmB,CAC1B,GAAkC,EAClC,qBAAwC;QAExC,8DAA8D;QAC9D,UAAU,CAAC,GAAG,EAAE;YACd,qBAAqB,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBACxC,IAAI;oBACF,OAAO,CAAC,GAAG,CAAC,CAAC;iBACd;gBAAC,OAAO,GAAG,EAAE;oBACZ,oDAAoD;oBACpD,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;iBACpB;YACH,CAAC,CAAC,CAAC;QACL,CAAC,CAAC,CAAC;IACL,CAAC;AACH,CAAC;AAnED,sEAmEC;AAED,SAAS,eAAe;IACtB,IAAI,OAAY,CAAC;IACjB,MAAM,OAAO,GAAkB,IAAI,OAAO,CAAC,CAAC,QAAQ,EAAE,EAAE;QACtD,OAAO,GAAG,QAAQ,CAAC;IACrB,CAAC,CAAC,CAAC;IACH,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC;AAC9B,CAAC","sourcesContent":["import clone from 'clone';\r\nimport {\r\n  createAsyncMiddleware,\r\n  JsonRpcMiddleware,\r\n  PendingJsonRpcResponse,\r\n} from 'json-rpc-engine';\r\nimport {\r\n  cacheIdentifierForPayload,\r\n  Block,\r\n  JsonRpcRequestToCache,\r\n} from './utils/cache';\r\n\r\ntype RequestHandlers = (handledRes: PendingJsonRpcResponse<Block>) => void;\r\ninterface InflightRequest {\r\n  [cacheId: string]: RequestHandlers[];\r\n}\r\n\r\nexport function createInflightCacheMiddleware(): JsonRpcMiddleware<string[], Block> {\r\n  const inflightRequests: InflightRequest = {};\r\n\r\n  return createAsyncMiddleware(async (req, res, next) => {\r\n    // allow cach to be skipped if so specified\r\n    if ((req as JsonRpcRequestToCache).skipCache) {\r\n      return next();\r\n    }\r\n    // get cacheId, if cacheable\r\n    const cacheId: string | null = cacheIdentifierForPayload(req);\r\n    // if not cacheable, skip\r\n    if (!cacheId) {\r\n      return next();\r\n    }\r\n    // check for matching requests\r\n    let activeRequestHandlers: RequestHandlers[] = inflightRequests[cacheId];\r\n    // if found, wait for the active request to be handled\r\n    if (activeRequestHandlers) {\r\n      // setup the response listener and wait for it to be called\r\n      // it will handle copying the result and request fields\r\n      await createActiveRequestHandler(res, activeRequestHandlers);\r\n      return undefined;\r\n    }\r\n    // setup response handler array for subsequent requests\r\n    activeRequestHandlers = [];\r\n    inflightRequests[cacheId] = activeRequestHandlers;\r\n    // allow request to be handled normally\r\n    // eslint-disable-next-line node/callback-return\r\n    await next();\r\n    // clear inflight requests\r\n    delete inflightRequests[cacheId];\r\n    // schedule activeRequestHandlers to be handled\r\n    handleActiveRequest(res, activeRequestHandlers);\r\n    // complete\r\n    return undefined;\r\n  });\r\n\r\n  function createActiveRequestHandler(\r\n    res: PendingJsonRpcResponse<Block>,\r\n    activeRequestHandlers: RequestHandlers[],\r\n  ): Promise<void> {\r\n    const { resolve, promise } = deferredPromise();\r\n    activeRequestHandlers.push((handledRes: PendingJsonRpcResponse<Block>) => {\r\n      // append a copy of the result and error to the response\r\n      res.result = clone(handledRes.result);\r\n      res.error = clone(handledRes.error);\r\n      resolve();\r\n    });\r\n    return promise;\r\n  }\r\n\r\n  function handleActiveRequest(\r\n    res: PendingJsonRpcResponse<Block>,\r\n    activeRequestHandlers: RequestHandlers[],\r\n  ): void {\r\n    // use setTimeout so we can resolve our original request first\r\n    setTimeout(() => {\r\n      activeRequestHandlers.forEach((handler) => {\r\n        try {\r\n          handler(res);\r\n        } catch (err) {\r\n          // catch error so all requests are handled correctly\r\n          console.error(err);\r\n        }\r\n      });\r\n    });\r\n  }\r\n}\r\n\r\nfunction deferredPromise() {\r\n  let resolve: any;\r\n  const promise: Promise<void> = new Promise((_resolve) => {\r\n    resolve = _resolve;\r\n  });\r\n  return { resolve, promise };\r\n}\r\n"]}