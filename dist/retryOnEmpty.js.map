{"version":3,"file":"retryOnEmpty.js","sourceRoot":"","sources":["../src/retryOnEmpty.ts"],"names":[],"mappings":";;;;;;AAAA,kDAA0B;AAE1B,qDAIyB;AACzB,gDAAwB;AAExB,yCAIuB;AAEvB,EAAE;AACF,gFAAgF;AAChF,+EAA+E;AAC/E,8DAA8D;AAC9D,qDAAqD;AACrD,EAAE;AAEF,gEAAgE;AAChE,0EAA0E;AAC1E,MAAM,WAAW,GAAkC;IACjD,SAAS;IACT,IAAI;IACJ,iBAAiB;CAClB,CAAC;AAOF,SAAgB,4BAA4B,CAAC,EAC3C,QAAQ,EACR,YAAY,MACqB,EAAE;IACnC,IAAI,CAAC,QAAQ,EAAE;QACb,MAAM,KAAK,CACT,kEAAkE,CACnE,CAAC;KACH;IACD,IAAI,CAAC,YAAY,EAAE;QACjB,MAAM,KAAK,CACT,sEAAsE,CACvE,CAAC;KACH;IAED,OAAO,uCAAqB,CAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,EAAE;;QACpD,MAAM,aAAa,GAAuB,0BAAkB,CAAC,GAAG,CAAC,CAAC;QAClE,2CAA2C;QAC3C,IAAI,aAAa,KAAK,SAAS,EAAE;YAC/B,OAAO,IAAI,EAAE,CAAC;SACf;QACD,qCAAqC;QACrC,IAAI,QAAQ,SAAuB,GAAG,CAAC,MAAM,0CAAG,aAAa,CAAC,CAAC;QAC/D,oCAAoC;QACpC,IAAI,QAAQ,KAAK,SAAS,EAAE;YAC1B,QAAQ,GAAG,QAAQ,CAAC;SACrB;QACD,qCAAqC;QACrC,IAAI,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;YAC5C,OAAO,IAAI,EAAE,CAAC;SACf;QACD,+CAA+C;QAC/C,MAAM,cAAc,GAAW,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;QACtE,IAAI,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE;YAChC,OAAO,IAAI,EAAE,CAAC;SACf;QACD,sBAAsB;QACtB,MAAM,oBAAoB,GAAW,MAAM,YAAY,CAAC,cAAc,EAAE,CAAC;QACzE,MAAM,iBAAiB,GAAW,MAAM,CAAC,QAAQ,CAC/C,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAC,EAC7B,EAAE,CACH,CAAC;QACF,sDAAsD;QACtD,IAAI,cAAc,GAAG,iBAAiB,EAAE;YACtC,OAAO,IAAI,EAAE,CAAC;SACf;QACD,+CAA+C;QAC/C,MAAM,YAAY,GAAG,eAAK,CAAC,GAAG,CAAC,CAAC;QAChC,6DAA6D;QAC7D,MAAM,aAAa,GAAkC,MAAM,KAAK,CAC9D,EAAE,EACF,KAAK,IAAI,EAAE;YACT,MAAM,eAAe,GAAkC,MAAM,cAAI,CAC9D,QAAqC,CAAC,SAAS,CACjD,CAAC,IAAI,CAAC,QAAQ,EAAE,YAAY,CAAC,CAAC;YAC/B,gBAAgB;YAChB,IAAI,WAAW,CAAC,QAAQ,CAAC,eAAsB,CAAC,EAAE;gBAChD,MAAM,IAAI,KAAK,CACb,4CAA4C,IAAI,CAAC,SAAS,CACxD,eAAe,CAChB,kBAAkB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,GAAG,CACnD,CAAC;aACH;YACD,OAAO,eAAe,CAAC;QACzB,CAAC,CACF,CAAC;QACF,6CAA6C;QAC7C,GAAG,CAAC,MAAM,GAAG,aAAa,CAAC,MAAM,CAAC;QAClC,GAAG,CAAC,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC;QAChC,OAAO,IAAI,EAAE,CAAC;IAChB,CAAC,CAAC,CAAC;AACL,CAAC;AAvED,oEAuEC;AAED,KAAK,UAAU,KAAK,CAClB,UAAkB,EAClB,OAAqD;IAErD,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,UAAU,EAAE,KAAK,EAAE,EAAE;QAC/C,IAAI;YACF,OAAO,MAAM,OAAO,EAAE,CAAC;SACxB;QAAC,OAAO,GAAG,EAAE;YACZ,MAAM,OAAO,CAAC,IAAI,CAAC,CAAC;SACrB;KACF;IACD,MAAM,IAAI,KAAK,CAAC,4CAA4C,CAAC,CAAC;AAChE,CAAC;AAED,SAAS,OAAO,CAAC,QAAgB;IAC/B,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC,CAAC;AACjE,CAAC","sourcesContent":["import clone from 'clone';\r\nimport { PollingBlockTracker } from 'eth-block-tracker';\r\nimport {\r\n  createAsyncMiddleware,\r\n  JsonRpcMiddleware,\r\n  PendingJsonRpcResponse,\r\n} from 'json-rpc-engine';\r\nimport pify from 'pify';\r\n\r\nimport {\r\n  Block,\r\n  blockTagParamIndex,\r\n  SafeEventEmitterProvider,\r\n} from './utils/cache';\r\n\r\n//\r\n// RetryOnEmptyMiddleware will retry any request with an empty response that has\r\n// a numbered block reference at or lower than the blockTracker's latest block.\r\n// Its useful for dealing with load-balanced ethereum JSON RPC\r\n// nodes that are not always in sync with each other.\r\n//\r\n\r\n// empty values used to determine if a request should be retried\r\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\r\nconst emptyValues: (string | null | undefined)[] = [\r\n  undefined,\r\n  null,\r\n  '\\u003cnil\\u003e',\r\n];\r\n\r\ninterface RetryOnEmptyMiddlewareOptions {\r\n  provider?: SafeEventEmitterProvider;\r\n  blockTracker?: PollingBlockTracker;\r\n}\r\n\r\nexport function createRetryOnEmptyMiddleware({\r\n  provider,\r\n  blockTracker,\r\n}: RetryOnEmptyMiddlewareOptions = {}): JsonRpcMiddleware<string[], Block> {\r\n  if (!provider) {\r\n    throw Error(\r\n      'RetryOnEmptyMiddleware - mandatory \"provider\" option is missing.',\r\n    );\r\n  }\r\n  if (!blockTracker) {\r\n    throw Error(\r\n      'RetryOnEmptyMiddleware - mandatory \"blockTracker\" option is missing.',\r\n    );\r\n  }\r\n\r\n  return createAsyncMiddleware(async (req, res, next) => {\r\n    const blockRefIndex: number | undefined = blockTagParamIndex(req);\r\n    // skip if method does not include blockRef\r\n    if (blockRefIndex === undefined) {\r\n      return next();\r\n    }\r\n    // skip if not exact block references\r\n    let blockRef: string | undefined = req.params?.[blockRefIndex];\r\n    // omitted blockRef implies \"latest\"\r\n    if (blockRef === undefined) {\r\n      blockRef = 'latest';\r\n    }\r\n    // skip if non-number block reference\r\n    if (['latest', 'pending'].includes(blockRef)) {\r\n      return next();\r\n    }\r\n    // skip if block refernce is not a valid number\r\n    const blockRefNumber: number = Number.parseInt(blockRef.slice(2), 16);\r\n    if (Number.isNaN(blockRefNumber)) {\r\n      return next();\r\n    }\r\n    // lookup latest block\r\n    const latestBlockNumberHex: string = await blockTracker.getLatestBlock();\r\n    const latestBlockNumber: number = Number.parseInt(\r\n      latestBlockNumberHex.slice(2),\r\n      16,\r\n    );\r\n    // skip if request block number is higher than current\r\n    if (blockRefNumber > latestBlockNumber) {\r\n      return next();\r\n    }\r\n    // create child request with specific block-ref\r\n    const childRequest = clone(req);\r\n    // attempt child request until non-empty response is received\r\n    const childResponse: PendingJsonRpcResponse<Block> = await retry(\r\n      10,\r\n      async () => {\r\n        const attemptResponse: PendingJsonRpcResponse<Block> = await pify(\r\n          (provider as SafeEventEmitterProvider).sendAsync,\r\n        ).call(provider, childRequest);\r\n        // verify result\r\n        if (emptyValues.includes(attemptResponse as any)) {\r\n          throw new Error(\r\n            `RetryOnEmptyMiddleware - empty response \"${JSON.stringify(\r\n              attemptResponse,\r\n            )}\" for request \"${JSON.stringify(childRequest)}\"`,\r\n          );\r\n        }\r\n        return attemptResponse;\r\n      },\r\n    );\r\n    // copy child response onto original response\r\n    res.result = childResponse.result;\r\n    res.error = childResponse.error;\r\n    return next();\r\n  });\r\n}\r\n\r\nasync function retry(\r\n  maxRetries: number,\r\n  asyncFn: () => Promise<PendingJsonRpcResponse<Block>>,\r\n): Promise<PendingJsonRpcResponse<Block>> {\r\n  for (let index = 0; index < maxRetries; index++) {\r\n    try {\r\n      return await asyncFn();\r\n    } catch (err) {\r\n      await timeout(1000);\r\n    }\r\n  }\r\n  throw new Error('RetryOnEmptyMiddleware - retries exhausted');\r\n}\r\n\r\nfunction timeout(duration: number): Promise<NodeJS.Timeout> {\r\n  return new Promise((resolve) => setTimeout(resolve, duration));\r\n}\r\n"]}